<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FRC Team Data</title>
    <style>
        /* Some basic styling */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        .container {
            max-width: 400px;
            margin: 50px auto;
            text-align: center;
            background-color: #fff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        input[type="text"] {
            padding: 10px;
            margin: 10px 0;
            width: calc(100% - 20px);
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
        }
        button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #0056b3;
        }
        #team-data {
            margin-top: 20px;
            text-align: center;
        }
        .statistic-container {
            background-color: #f0f0f0;
            padding: 10px;
            border-radius: 10px;
            margin-top: 10px;
        }
        @keyframes drawCircle {
            0% {
                stroke-dasharray: 0 251.2; /* Length of circle circumference */
            }
            100% {
                stroke-dasharray: 251.2 0; /* Draw complete circle */
            }
        }
        .circle {
            fill: none;
            stroke-width: 30; /* Outline width */
            stroke-dasharray: 0 251.2; /* Initial state (not visible) */
            stroke-dashoffset: 0; /* Starting position */
            border-radius: 50%;
            cursor: pointer; /* Change cursor to pointer when hovering over circle */
        }

        }
        .circle {
            fill: none;
            stroke-width: 30; /* Outline width */
            stroke-dasharray: 0 251.2; /* Initial state (not visible) */
            stroke-dashoffset: 0; /* Starting position */
            border-radius: 50%;
            cursor: pointer; /* Change cursor to pointer when hovering over circle */
            position: relative; /* Ensure the circle is positioned correctly */
            z-index: 1; /* Ensure the circle is on top */
        }
        .score-text {
            position: absolute; /* Position the text relative to the SVG */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* Center the text */
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>3324 - Team Analysis</h2>
        <input type="text" id="teamNumbers" placeholder="####...">
        <button onclick="getTeamData()">Search</button>
        <div id="team-data"></div>
    </div>

    <script>
        function getTeamData() {
            checkInputFormat();
            var teamNumbers = document.getElementById('teamNumbers').value.split(',').map(num => num.trim());

            Promise.all(teamNumbers.map(teamNumber => {
                return fetch(`https://api.statbotics.io/v3/team_year/${teamNumber}/${new Date().getFullYear()}`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Failed to fetch team data. Status: ' + response.status);
                        }
                        return response.json();
                    });
            }))
            .then(teamDataArray => {
                if (teamDataArray.length === 1) {
                    var teamData = teamDataArray[0];
                    var teamPerformance = calculateTeamPerformance(teamData);
                    displaySingleTeamData(teamData, teamPerformance);
                } else {
                    var aggregatedData = aggregateTeamData(teamDataArray);
                    displayAggregatedData(aggregatedData, teamDataArray);
                    // Check if there are 6 teams before showing the circle
                    if (teamNumbers.length === 6) {
                        animateCircle(aggregatedData.compositeScore); // Start the circle animation with color based on performance
                    }
                }
            })
            .catch(error => {
                console.error('Error fetching team data:', error.message);

            });
        }

        function calculateTeamPerformance(data) {
            // Placeholder maximum possible statistics
            var maximumPossibleMatchScore = 130;
            var maximumPossibleTeleopScore = 95;
            var maximumPossibleAutoScore = 20;
            var maximumPossibleEndgameScore = 15;
            // Extract relevant statistics
            var winLossRatio = data.record.season.winrate;
            var overallRank = data.epa.ranks.total.rank;
            var totalNumberOfTeams = data.epa.ranks.total.team_count;
            var averageMatchScore = data.epa.breakdown.total_points.mean;
            var averageTeleopScore = data.epa.breakdown.teleop_points.mean;
            var rankingInArea = data.epa.ranks.state.rank;
            var averageAutoScore = data.epa.breakdown.auto_points.mean;
            var averageEndgameScore = data.epa.breakdown.endgame_points.mean;
            // Extract standard deviations
            var sdMatchScore = data.epa.breakdown.total_points.sd;
            var sdTeleopScore = data.epa.breakdown.teleop_points.sd;
            var sdAutoScore = data.epa.breakdown.auto_points.sd;
            var sdEndgameScore = data.epa.breakdown.endgame_points.sd;
            // Normalize each statistic to a scale of 0 to 1
            var normalizedWinLossRatio = winLossRatio; // Assuming winLossRatio is already normalized
            var normalizedOverallRank = 1 - (overallRank - 1) / totalNumberOfTeams; // Assuming lower rank is better
            var normalizedAverageMatchScore = averageMatchScore / maximumPossibleMatchScore;
            var normalizedAverageTeleopScore = averageTeleopScore / maximumPossibleTeleopScore;
            var normalizedAverageAutoScore = averageAutoScore / maximumPossibleAutoScore;
            var normalizedEndgameScore = averageEndgameScore / maximumPossibleEndgameScore;
            var normalizedRankingInArea = 1 - (rankingInArea - 1) / totalNumberOfTeams; // Assuming lower rank is better
            // Assign equal weights to each statistic
            var weight = 1 / 7; // Total number of statistics
            // Calculate the composite score
            var compositeScore = (normalizedWinLossRatio + normalizedOverallRank + normalizedAverageMatchScore + normalizedAverageTeleopScore + normalizedAverageAutoScore + normalizedEndgameScore + normalizedRankingInArea) * weight;
            return compositeScore;
        }

        function aggregateTeamData(teamDataArray) {
            var totalPerformance = 0;

            teamDataArray.forEach(data => {
                totalPerformance += calculateTeamPerformance(data);
            });

            var averagePerformance = totalPerformance / teamDataArray.length;

            return {
                compositeScore: averagePerformance
            };
        }

        function displaySingleTeamData(data, performance) {
            var teamData = document.getElementById('team-data');
            teamData.innerHTML = `
                <h2>${data.name} (${new Date().getFullYear()})</h2>
                <svg width="200" height="200" onclick="toggleTeamData()">
                    <circle class="circle" cx="100" cy="100" r="80"></circle>
                    <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="black" font-size="24px">${performance.toFixed(2)}</text>
                </svg>


                <div class="statistic-container">
                    <p>Win-Loss Ratio (0-1): ${data.record.season.winrate.toFixed(4)}</p>
                    ${data.epa.ranks.total ? `<p>Overall Rank (World): ${data.epa.ranks.total.rank} / ${data.epa.ranks.total.team_count}</p>` : ''}
                    <p>Average Match Score: ${data.epa.breakdown.total_points.mean.toFixed(2)} ± (${data.epa.breakdown.total_points.sd.toFixed(2)})</p>
                    <p>Average Teleop Score: ${data.epa.breakdown.teleop_points.mean.toFixed(2)} ± (${data.epa.breakdown.teleop_points.sd.toFixed(2)})</p>
                    <p>Average Auto Score: ${data.epa.breakdown.auto_points.mean.toFixed(2)} ± (${data.epa.breakdown.auto_points.sd.toFixed(2)})</p>
                    <p>Endgame Score: ${data.epa.breakdown.endgame_points.mean.toFixed(2)} ± (${data.epa.breakdown.endgame_points.sd.toFixed(2)})</p>
                    ${data.state ? `<p>Ranking in Area: ${data.epa.ranks.state.rank} / ${data.epa.ranks.state.team_count} (${data.state})</p>` : ''}
                </div>
            `;
          animateCircle(performance); // Start the circle animation with color based on performance
        }

        function displayAggregatedData(aggregatedData, teamDataArray) {
            var teamData = document.getElementById('team-data');
            var totalWinLossRatio = 0;
            var totalOverallRank = 0;
            var totalAverageMatchScore = 0;
            var totalAverageTeleopScore = 0;
            var totalAverageAutoScore = 0;
            var totalEndgameScore = 0;
            var teamNames = ''; // Initialize an empty string to store team names

            teamDataArray.forEach(data => {
                totalWinLossRatio += data.record.season.winrate;
                totalOverallRank += data.epa.ranks.total.rank;
                totalAverageMatchScore += data.epa.breakdown.total_points.mean;
                totalAverageTeleopScore += data.epa.breakdown.teleop_points.mean;
                totalAverageAutoScore += data.epa.breakdown.auto_points.mean;
                totalEndgameScore += data.epa.breakdown.endgame_points.mean;

                // Append team name to the list
                teamNames += `${data.name}, `;
            });

            // Remove the trailing comma and space
            teamNames = teamNames.slice(0, -2);

            var averageWinLossRatio = totalWinLossRatio / teamDataArray.length;
            var averageOverallRank = totalOverallRank / teamDataArray.length;
            var averageAverageMatchScore = totalAverageMatchScore;
            var averageAverageTeleopScore = totalAverageTeleopScore;
            var averageAverageAutoScore = totalAverageAutoScore;
            var averageEndgameScore = totalEndgameScore;

            var compositeScore = aggregatedData.compositeScore;

            teamData.innerHTML = `
                <h2>Alliance Data</h2>
<svg width="200" height="200" onclick="toggleTeamData()">
            <circle class="circle" cx="100" cy="100" r="80"></circle>
            <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="black" font-size="24px">${compositeScore.toFixed(2)}</text>
        </svg>
                <div class="statistic-container">
                    <p>Teams: ${teamNames}</p> <!-- Display team names here -->
                    <p>Est. Win-Loss Ratio: ${averageWinLossRatio.toFixed(4)}</p>
                    <p>Est. Average Match Score: ${averageAverageMatchScore.toFixed(2)}</p>
                    <p>Est. Average Teleop Score: ${averageAverageTeleopScore.toFixed(2)}</p>
                    <p>Est. Average Auto Score: ${averageAverageAutoScore.toFixed(2)}</p>
                    <p>Est. Average Endgame Score: ${averageEndgameScore.toFixed(2)}</p>
                </div>
            `;
          animateCircle(compositeScore); // Start the circle animation with color based on performance
        }

        function animateCircle(performance) {
            var circle = document.querySelector('.circle');
            circle.style.animation = 'none'; // Reset animation
            circle.getBoundingClientRect(); // Trigger reflow to restart animation
            circle.style.animation = 'drawCircle 1s ease forwards'; // Start animation
            var color = getColorForPerformance(performance); // Get color based on performance
            circle.style.stroke = color; // Set stroke color
        }

        function toggleTeamData() {
            var teamData = document.querySelector('.statistic-container');
            teamData.style.display = teamData.style.display === 'none' ? 'block' : 'none';
        }

        function getColorForPerformance(performance) {
            var hue = performance * 120; // Convert performance to hue (0 to 120)
            var color;
            if (performance <= 0.5) {
                // Red to yellow transition
                color = "hsl(" + hue + ",100%,50%)"; // Red to yellow
            } else {
                // Yellow to green transition
                color = "hsl(" + hue + ",100%,50%)"; // Yellow to green
            }
            return color;
        }

        function checkInputFormat() {
            var teamNumbersInput = document.getElementById('teamNumbers').value;
            var regex = /^(\d{1,4}(, \d{1,4})* - \d{1,4}(, \d{1,4})*)?$/;
            if (regex.test(teamNumbersInput)) {
                console.log('Input matches the desired format:', teamNumbersInput);
                // Call the function to fetch and process team data
                fetchAndProcessTeamData(teamNumbersInput);
            } else {
                console.log('Input does not match the desired format.');
            }
        }

        function fetchAndProcessTeamData(teamNumbersInput) {
            // Split the input into two groups: before and after the hyphen
            var [group1, group2] = teamNumbersInput.split(' - ');
            // Split each group into individual team numbers
            var teamNumbers1 = group1.split(',').map(num => num.trim());
            var teamNumbers2 = group2.split(',').map(num => num.trim());

            // Fetch data for each team in both groups
            Promise.all([...teamNumbers1, ...teamNumbers2].map(teamNumber => {
                return fetch(`https://api.statbotics.io/v3/team_year/${teamNumber}/${new Date().getFullYear()}`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Failed to fetch team data. Status: ' + response.status);
                        }
                        return response.json();
                    });
            }))
            .then(teamDataArray => {
                // Sum the points for the specified teams
                var totalPoints1 = teamDataArray.slice(0, 3).reduce((sum, data) => sum + data.epa.breakdown.total_points.mean, 0);
                var totalPoints2 = teamDataArray.slice(3, 6).reduce((sum, data) => sum + data.epa.breakdown.total_points.mean, 0);

                // Display the summed points for each group
                displaySummedPoints(totalPoints1, totalPoints2, teamDataArray);
            })
            .catch(error => {
                console.error('Error fetching or processing team data:', error);
            });
        }

function displaySummedPoints(totalPoints1, totalPoints2, teamDataArray) {
    var teamData = document.getElementById('team-data');
    var p1 = totalPoints1.toFixed(2);
    var p2 = totalPoints2.toFixed(2);
    var pd1 = totalPoints1.toFixed(2) - totalPoints2.toFixed(2);
    var pd2 = totalPoints2.toFixed(2) - totalPoints1.toFixed(2);
    teamData.innerHTML = '<h2>Summed Points for Each Group</h2>';

    teamData.innerHTML += `<p>Red Alliance: <b>${p1}</b></p>`;
    teamData.innerHTML += `<p>Blue Alliance: <b>${p2}</b></p>`;

    if (pd2 > 0) {
      teamData.innerHTML += `<p>Point Diff: <b><span style="color: red;">${pd2} (A1)</span></b></p>`;
    } else {
            teamData.innerHTML += `<p>Point Diff: <b><span style="color: blue;">${pd1} (A2)</span></b></p>`;
    }
     
}

    </script>
</body>
</html>
